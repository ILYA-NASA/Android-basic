### Реактивное программирование — [парадигма программирования](https://github.com/ILYA-NASA/Software_design/blob/main/README.md#Парадигмы-программирования), ориентированная на асинхронную работу с потоками данных и распространение изменений.
### Поток данных — упорядоченный набор данных, распределённый во времени.
### Реактивность — способность программы реагировать на изменение данных.

### Observer — [паттерн проектирования](https://github.com/ILYA-NASA/Software_design/blob/main/Object-oriented/Паттерны%20ООП%20(обзорно).pdf), который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на изменения, происходящие в другом объекте.  
● Есть объект, который может изменяться  
● Другие объекты подписываются на изменения этого объекта  
● Когда внутреннее состояние объекта изменится, все
подписчики получат уведомление об этом и смогут
выполнить необходимый код  

### Flow — тип данных, который описывает последовательность элементов определённого типа (поток данных). 
Каждый элемент потока данных может вычисляться асинхронно.  
Flow основаны на корутинах и suspend-функциях.  

![Flow](https://github.com/ILYA-NASA/Android-basic/assets/99810114/8aa321c0-9df9-4953-8142-74752b7fff5a)

### Источники данных:
**Hot** (горячий) — производят данные независимо от того, есть ли потребители этих данных.  
**Cold** (холодный) — производят данные только в том случае,
если есть потребитель данных.  
Чаще всего Flow — холодные источники данных.  
Исключения — **[SharedFlow](#SharedFlow)**, **[StateFlow](#StateFlow)**.

### Flow создаётся с помощью специальных функций-билдеров:
● **flow {}** — базовый билдер.  
Создаёт поток данных и принимает
в качестве аргумента suspend лямбда-выражение  
● **flowOf(vararg elements: T)** — создаёт поток данных на основании
переданных элементов  
● **asFlow()** — extension-функция.  
Позволяет преобразовать объект
в flow.  
Можно преобразовать **suspend**-функцию, любую
из коллекций и любой другой тип данных, для которых
определено это расширение  

### Для получения данных необходимо использовать один из _терминальных операторов_.
Основные из них:  
● **collect** — базовый терминальный оператор.  
Получает элементы из **flow** и позволяет
обрабатывать их
● **single** — оператор, который получает только один элемент и возвращает его  
● **reduce, fold** — операторы, которые аккумулируют все значения в одно и возвращают его  
● **first, firstOrNull, last, lastOrNull** — операторы, которые возвращают
первый/последний элемент  
● **toList, toSet** — операторы, которые возвращают коллекцию элементов  

### Intermediate operators — промежуточные операторы, которые применяются к уже существующему потоку данных. 
С помощью этих операторов значения элементов в этом потоке можно изменить.  

![image](https://github.com/ILYA-NASA/Android-basic/assets/99810114/a6e9238c-4147-44c6-a761-d65070b707e9)

● Фильтрация: **filter, filterNot, filterNotNull, distinctUntilChanged**  
● Преобразование: **map, mapNotNull, flatmapConcat, flatmapMerge, flatmapLatest**  
● Ограничение количества: **take, takeWhile, drop, dropWhile**  
● Обработка ошибок: **catch, retry**  
● Обработка событий потока: **onEach, onCompletion, onEmpty, onStart**  
● Уменьшение частоты потока: **debounce, sample**  
● Изменение диспетчера: **flowOn**  

### Объединение потоков данных
Операторы **zip**, **combine** объединяют два **flow** в один с помощью
предоставленной функции трансформации.  
Результатом является новый **flow**, элементами которого являются
преобразованные значения.  

### SharedFlow
● Горячий источник данных  
● Может иметь несколько подписчиков  
● Изменения получают все подписчики  
● Вызов функции **collect** никогда не заканчивается  

При создании **SharedFlow** можно задать:  
* величину буфера  
* количество элементов, которые получит новый подписчик из буфера  
* стратегию, если буфер переполнен:  
  * приостановить производство элементов  
  * удалить из буфера самый старый элемент  
  * удалить последний добавленный элемент  

Для добавления элементов в поток данных используются функции:  
● **emit** — добавляет элемент в поток данных. Может быть
приостановлена при переполнении буфера  
● **tryEmit** — пытается добавить элемент в поток данных.  
Возвращает **false**, если добавить элемент не удалось — буфер переполнен

### StateFlow 
**flow**, который всегда содержит только одно значение, которое может обновляться.
● **StateFlow** наследуется от **SharedFlow**  
● Добавление значения в поток происходит с помощью изменения
поля **value**  
● Нельзя добавить подряд одинаковые элементы  

**StateFlow** может быть представлен в виде **SharedFlow**  

Разработан для распространения состояний.  
Чаще всего состояния программы — это стейт-машина.  

### :paperclip: [Программа](https://github.com/ILYA-NASA/Android-basic/tree/master/15_Flow/LottoGame/src/main/kotlin), которая имитирует [настольную игру «Лото»](https://github.com/ILYA-NASA/Android-basic/blob/master/15_Flow/LottoGame/TASK.md), реализованная с применением различных flow-билдеров.
