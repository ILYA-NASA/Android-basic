### Парадигма — способ мышления, восприятия.

### Процедурное программирование — последовательное выполнение каких-то действий и команд.

### Объектно-ориентированное программирование ([ООП](https://github.com/ILYA-NASA/Software_design/blob/main/README.md#Объектно-ориентированное-программирование)) — представление программы в виде объектов и взаимоотношений между ними.

### Объект — что-то, что имеет своё состояние и поведение: мобильный телефон, компьютер, дерево, ручка для письма и т. д.

Основные принципы **ООП**:  
● инкапсуляция  
● наследование  
● полиморфизм  
Дополнительно рассматривают четвёртый принцип, который относится ко всем парадигмам:  
● абстракция  

### Инкапсуляция
● Языковая конструкция, позволяющая связать данные с методами, предназначенными для обработки этих данных  
● Механизм языка, позволяющий ограничить доступ одних компонентов программы к другим  

Для чего нужна **инкапсуляция**:  
● скрыть от пользователя детали реализации класса  
● предоставить определённые интерфейсы для взаимодействия с классом  
Это обеспечивает:  
● максимально стабильную и прогнозируемую работу программы  
● максимально простое взаимодействие между компонентами  

**Инкапсуляция** достигается с помощью:  
● модификаторов доступа  
● геттеров и сеттеров  

### Наследование — механизм, который позволяет описывать новый класс на основе уже имеющегося, взяв за основу все методы и поля этого класса.
Класс, который взят за основу, называют **базовым**, **родительским**, **предком** или **суперклассом**.  
Класс на его основе называют **потомком**, **наследником**, **дочерним** или **производным** классом.  
Производный класс обладает всеми теми же свойствами, что и базовый класс, а также может иметь свои собственные поля и функции.  

Для чего нужно **наследование**:  
● описывать и создавать иерархии классов, структурировать и систематизировать классы  
● переиспользовать уже написанный код и избегать ненужного дублирования или копирования кода  
● основа для полиморфизма  

Отношение **«is-a»** (является) между производным и базовым классом:  
● экземпляр производного класса является экземпляром базового  
● экземпляр базового класса не является экземпляром производного класса  

Правила **наследования**:  
● наследоваться можно только от открытых классов. Чтобы сделать класс открытым, необходимо
установить ему модификатор **open**. По умолчанию в Kotlin все классы закрыты для наследования  
● если у производного класса есть первичный конструктор, то базовый класс должен быть
проинициализирован в оглавлении класса. Если первичного конструктора
нет, то все дополнительные конструкторы должны явно вызывать один из конструкторов базового
класса с помощью ключевого слова **super**

При наследовании класс-потомок содержит все доступные поля и методы базового класса.  
Наследование позволяет переопределять поля и функции базового класса с помощью ключевого
слова **override**.  

### :paperclip: [Программа](https://github.com/ILYA-NASA/Android-basic/tree/master/09_OOP1/practice/src/main/kotlin), имитирующая [жизненный цикл животных в заповеднике](https://github.com/ILYA-NASA/Android-basic/blob/master/09_OOP1/practice/TASK.md), реализованная с применением инкапсуляции и наследования.
